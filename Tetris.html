<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üçé Fruit Tetris</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #1e1e1e;
            color: white;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px 0;
        }
        #game-container {
            border: 5px solid #ff7700; /* Orange border */
            box-shadow: 0 0 20px rgba(255, 119, 0, 0.7);
        }
        #controls {
            margin-top: 20px;
            display: grid;
            grid-template-areas:
                ". Up ."
                "Left Down Right"
                ". Rotate .";
            gap: 10px;
            width: 300px;
            max-width: 80vw;
        }
        .control-btn {
            background-color: #333;
            color: white;
            border: 2px solid #555;
            padding: 15px 10px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.1s;
            user-select: none; /* Prevent text selection on mobile */
        }
        .control-btn:active {
            background-color: #555;
        }
        #Up { grid-area: Up; }
        #Left { grid-area: Left; }
        #Down { grid-area: Down; }
        #Right { grid-area: Right; }
        #Rotate { grid-area: Rotate; }
        h1 { color: #ff7700; margin-bottom: 10px; }
        #score-display {
            margin: 10px 0;
            font-size: 20px;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <h1>üçé Fruit Tetris üçá</h1>
    <div id="score-display">Score: 0</div>
    <canvas id="game-container" width="300" height="600"></canvas>

    <h2>üì± Touch Controls (Use for phone play)</h2>
    <div id="controls">
        <button id="Up" class="control-btn" data-action="Up">UP (Fast Drop)</button>
        <button id="Left" class="control-btn" data-action="Left">LEFT</button>
        <button id="Down" class="control-btn" data-action="Down">DOWN</button>
        <button id="Right" class="control-btn" data-action="Right">RIGHT</button>
        <button id="Rotate" class="control-btn" data-action="Rotate">ROTATE</button>
    </div>

    <script>
        // --- GAME CONSTANTS ---
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30; // 30px per fruit square
        const canvas = document.getElementById('game-container');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        
        // Fruit/Shape definitions
        // (Coordinates are relative to the shape's top-left pivot)
        const SHAPES = [
            // I-Banana üçå (Yellow)
            [[[0, 1], [1, 1], [2, 1], [3, 1]], 'üçå', '#FFFF00'],
            // J-Lime üçà (Light Green)
            [[[1, 0], [1, 1], [1, 2], [0, 2]], 'üçà', '#90EE90'],
            // L-Grape üçá (Purple)
            [[[0, 0], [0, 1], [0, 2], [1, 2]], 'üçá', '#800080'],
            // O-Orange üçä (Orange)
            [[[0, 0], [1, 0], [0, 1], [1, 1]], 'üçä', '#FFA500'],
            // S-Strawberry üçì (Red/Pink)
            [[[1, 0], [2, 0], [0, 1], [1, 1]], 'üçì', '#FF69B4'],
            // T-Pineapple üçç (Gold/Brown)
            [[[1, 0], [0, 1], [1, 1], [2, 1]], 'üçç', '#DAA520'],
            // Z-Cherry üçí (Dark Red)
            [[[0, 0], [1, 0], [1, 1], [2, 1]], 'üçí', '#B22222'],
        ];

        // --- GAME STATE ---
        let grid;
        let currentShape;
        let nextShape;
        let score = 0;
        let gameOver = false;
        let fallInterval;
        let dropSpeed = 1000; // milliseconds

        // --- CORE FUNCTIONS ---

        /** Initializes the game board grid. */
        function initGrid() {
            grid = Array.from({ length: ROWS }, () => 
                Array(COLS).fill(null) // null means empty
            );
        }

        /** Spawns a new random shape. */
        function newShape() {
            if (!nextShape) {
                // Initial spawn: get two shapes
                const index1 = Math.floor(Math.random() * SHAPES.length);
                const index2 = Math.floor(Math.random() * SHAPES.length);
                currentShape = {
                    shape: SHAPES[index1][0],
                    fruit: SHAPES[index1][1],
                    color: SHAPES[index1][2],
                    x: Math.floor(COLS / 2) - 2, // Start in the middle
                    y: 0,
                };
                nextShape = {
                    shape: SHAPES[index2][0],
                    fruit: SHAPES[index2][1],
                    color: SHAPES[index2][2],
                };
            } else {
                // Move the next shape to the current shape slot
                currentShape = {
                    ...nextShape,
                    x: Math.floor(COLS / 2) - 2,
                    y: 0,
                };
                
                // Generate a new next shape
                const index = Math.floor(Math.random() * SHAPES.length);
                nextShape = {
                    shape: SHAPES[index][0],
                    fruit: SHAPES[index][1],
                    color: SHAPES[index][2],
                };
            }

            // Game Over Check
            if (checkCollision(0, 0, currentShape.shape)) {
                gameOver = true;
                clearInterval(fallInterval);
                draw(); // Final draw for game over screen
                alert(`Game Over! Final Score: ${score}`);
            }
        }

        /** Checks if a shape collides with the walls or settled blocks. */
        function checkCollision(dx, dy, shape) {
            for (const [r, c] of shape) {
                const newRow = currentShape.y + r + dy;
                const newCol = currentShape.x + c + dx;

                // 1. Check vertical boundaries (bottom wall)
                if (newRow >= ROWS) return true;
                // 2. Check horizontal boundaries (left/right walls)
                if (newCol < 0 || newCol >= COLS) return true;
                // 3. Check for collision with existing blocks (ignore top boundary check for spawn)
                if (newRow >= 0 && grid[newRow] && grid[newRow][newCol] !== null) {
                    return true;
                }
            }
            return false;
        }

        /** Moves the shape down, or locks it if collision occurs. */
        function drop() {
            if (!checkCollision(0, 1, currentShape.shape)) {
                currentShape.y++;
            } else {
                lockShape();
                clearLines();
                newShape();
            }
            draw();
        }

        /** Locks the current shape into the grid. */
        function lockShape() {
            for (const [r, c] of currentShape.shape) {
                const row = currentShape.y + r;
                const col = currentShape.x + c;
                if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
                    grid[row][col] = { fruit: currentShape.fruit, color: currentShape.color };
                }
            }
        }

        /** Clears any completed lines and updates the score. */
        function clearLines() {
            let linesCleared = 0;
            for (let r = ROWS - 1; r >= 0; r--) {
                // Check if the row is full (no nulls)
                if (grid[r].every(cell => cell !== null)) {
                    // Line is full, clear it and shift everything above down
                    grid.splice(r, 1);
                    grid.unshift(Array(COLS).fill(null)); // Add new empty row at the top
                    linesCleared++;
                    r++; // Re-check the current (now shifted) row
                }
            }

            if (linesCleared > 0) {
                // Scoring system: 100 for 1, 300 for 2, 500 for 3, 800 for 4
                const points = [0, 100, 300, 500, 800];
                score += points[linesCleared];
                scoreDisplay.textContent = `Score: ${score}`;
                // Future: Increase speed
            }
        }

        /** Rotates the shape and checks for collision. */
        function rotateShape() {
            // Standard 90-degree rotation formula: (r, c) -> (c, size - 1 - r)
            const rotatedShape = currentShape.shape.map(([r, c]) => {
                // Treat the current shape as being in a bounding box (usually 4x4)
                // This formula works for a simple 4x4 grid: (c, 3 - r)
                return [c, 3 - r]; 
            });

            if (!checkCollision(0, 0, rotatedShape)) {
                currentShape.shape = rotatedShape;
                draw();
            }
        }

        /** Moves the shape left or right. */
        function move(dx) {
            if (!checkCollision(dx, 0, currentShape.shape)) {
                currentShape.x += dx;
                draw();
            }
        }

        /** Hard drop (moves shape immediately to the bottom). */
        function hardDrop() {
            let dy = 0;
            while (!checkCollision(0, dy + 1, currentShape.shape)) {
                dy++;
            }
            currentShape.y += dy;
            drop(); // Lock the shape and spawn the next one
        }
        
        // --- DRAWING ---

        /** Draws a single fruit block at grid coordinates (x, y). */
        function drawBlock(col, row, fruit, color) {
            const x = col * BLOCK_SIZE;
            const y = row * BLOCK_SIZE;
            
            // 1. Draw the colored background square
            ctx.fillStyle = color;
            ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
            
            // 2. Draw the fruit emoji
            ctx.font = `${BLOCK_SIZE * 0.8}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(fruit, x + BLOCK_SIZE / 2, y + BLOCK_SIZE / 2);

            // 3. Draw black grid line border
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
        }

        /** Main drawing loop. */
        function draw() {
            // Clear the canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 1. Draw settled blocks
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (grid[r][c]) {
                        drawBlock(c, r, grid[r][c].fruit, grid[r][c].color);
                    }
                }
            }

            // 2. Draw the current falling shape
            if (currentShape) {
                for (const [r, c] of currentShape.shape) {
                    drawBlock(
                        currentShape.x + c, 
                        currentShape.y + r, 
                        currentShape.fruit, 
                        currentShape.color
                    );
                }
            }

            if (gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#FF4500';
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 20);
                ctx.font = '20px Arial';
                ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 + 20);
            }
        }

        // --- INPUT HANDLING ---

        /** Handles keyboard input for desktop play. */
        document.addEventListener('keydown', (e) => {
            if (gameOver) return;
            switch (e.key) {
                case 'ArrowLeft':
                    move(-1);
                    break;
                case 'ArrowRight':
                    move(1);
                    break;
                case 'ArrowDown':
                    drop(); // Soft drop
                    break;
                case 'ArrowUp':
                case ' ': // Space bar for hard drop
                    hardDrop();
                    break;
                case 'r': // 'r' for rotate
                    rotateShape();
                    break;
            }
        });

        /** Handles touch button input for mobile play. */
        document.getElementById('controls').addEventListener('click', (e) => {
            if (gameOver || !e.target.dataset.action) return;
            
            const action = e.target.dataset.action;
            switch (action) {
                case 'Left':
                    move(-1);
                    break;
                case 'Right':
                    move(1);
                    break;
                case 'Down':
                    drop(); // Soft drop
                    break;
                case 'Up':
                    hardDrop(); // Up button triggers Hard Drop
                    break;
                case 'Rotate':
                    rotateShape();
                    break;
            }
        });


        // --- GAME INITIALIZATION ---
        function startGame() {
            initGrid();
            score = 0;
            gameOver = false;
            scoreDisplay.textContent = `Score: 0`;
            newShape();
            
            // Set up the automatic drop interval
            if (fallInterval) clearInterval(fallInterval);
            fallInterval = setInterval(drop, dropSpeed);
            
            draw();
        }

        // Start the game when the page loads
        startGame();

    </script>
</body>
</html>
